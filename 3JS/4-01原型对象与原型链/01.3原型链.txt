1 原型链
    对象的属性和方法,有可能是定义在自身内,也有可能是定义在它的原型对象上.
    由于原型自身也是对象,又有自己的原型,所以形成了一条原型链(prototype chain)
    比如: a对象是b对象的原型,b对象是c对象的原型,以此类推.

    如果一层一层的上溯,所有对象的原型最终都可以上溯到Object,
    那么,Object对象有没有它的原型呢?
    有的,就是没有任何属性和方法的null,而null对象没有自己的原型.
    原理上Object没有原型,但是获取到的是null,null就是空


2 原型链的作用
    JS对象的属性和方法一样,只是 = 后面不同

    读取对象的某个属性时,JS引擎现寻找对象本身的属性,如果找不到,就到它的原型去找,
    如果还是找不到,就取原型的原型去找.
    直到最终到最顶层的Object.prototype还是找不到,就返回undefined.
    如果对象自身和它的原型,都定义了一个同名属性,那么优先读取对象自身的属性,叫做"覆盖"

    注意: (1) 一级级向上,在原型链寻找某个属性,对性能是有影响的.
              如果寻找某个不存在的属性,将会遍历整个原型链.    

          (2) 实际开发中,我们通常会使用第三方框架(一个类),但是当我们发现这个类并不存在想要的属性和方法,不能直接修改源代码,
              但是可以通过原型对象添加我们的属性或方法


2 获取原型对象的方式

    (1) 构造函数来查看原型对象prototype   
        Cat.prototype
        
    (2) 通过对象自身查看原型对象
        cat1.__proto__

    (3) Object.getPrototypeOf(cat1);

        var a = Cat.prototype;
        var b = cat1.__proto__;
        var c = Object.getPrototypeOf(cat1);
        console.log(a); //Object { … }
        console.log(b); //Object { … }
        console.log(c); //Object { … }

    注意: 前两种方式不是很可靠,在最新的es6标准规定中,proto属性只有在浏览器中才能部署,其他环境不部署,
          而 Cat.prototype 在手动改变原型对象时会失败
        推荐使用第三种方式
